// Copyright 2021-present The Atlas Authors. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

package postgres

import (
	"fmt"
	"strings"

	"ariga.io/atlas/sql/internal/sqlx"
	"ariga.io/atlas/sql/schema"
)

// crdbDiff decorates PostgreSQL diff.
type crdbDiff struct{ diff }

// SchemaAttrDiff returns a changeset for migrating schema attributes from one state to the other.
func (cd *crdbDiff) SchemaAttrDiff(from, to *schema.Schema) []schema.Change {
	return cd.diff.SchemaAttrDiff(from, to)
}

// TableAttrDiff returns a changeset for migrating table attributes from
func (cd *crdbDiff) TableAttrDiff(from, to *schema.Table) ([]schema.Change, error) {
	return cd.diff.TableAttrDiff(from, to)
}

// ColumnChange returns the schema changes (if any) for migrating one column to the other.
func (cd *crdbDiff) ColumnChange(from, to *schema.Column) (schema.ChangeKind, error) {
	return cd.diff.ColumnChange(from, to)
}

// IndexAttrChanged reports if the index attributes were changed.
func (cd *crdbDiff) IndexAttrChanged(from, to []schema.Attr) bool {
	t1 := &IndexType{T: IndexTypeBTree}
	if sqlx.Has(from, t1) {
		t1.T = strings.ToUpper(t1.T)
	}
	t2 := &IndexType{T: IndexTypeBTree}
	if sqlx.Has(to, t2) {
		t2.T = strings.ToUpper(t2.T)
	}
	if t1.T != t2.T {
		return true
	}
	var p1, p2 IndexPredicate
	return sqlx.Has(from, &p1) != sqlx.Has(to, &p2) || (p1.P != p2.P && p1.P != sqlx.MayWrap(p2.P))
}

// IndexPartAttrChanged reports if the index-part attributes were
func (cd *crdbDiff) IndexPartAttrChanged(from, to *schema.IndexPart) bool {
	return cd.diff.IndexPartAttrChanged(from, to)
}

// IsGeneratedIndexName reports if the index name was generated by the database
func (cd *crdbDiff) IsGeneratedIndexName(t *schema.Table, i *schema.Index) bool {
	return cd.diff.IsGeneratedIndexName(t, i)
}

// ReferenceChanged reports if the foreign key referential action was
func (cd *crdbDiff) ReferenceChanged(from, to schema.ReferenceOption) bool {
	return cd.diff.ReferenceChanged(from, to)
}

func (cd *crdbDiff) crdbNormalize(table *schema.Table) {
	if table.PrimaryKey == nil {
		prim, ok := table.Column("rowid")
		if !ok {
			prim = schema.NewColumn("rowid").
				AddAttrs(Identity{}).
				SetType(&schema.IntegerType{})
			table.AddColumns(prim)
		}
		table.PrimaryKey = &schema.Index{
			Name:   "primary",
			Unique: true,
			Table:  table,
			Parts: []*schema.IndexPart{{
				SeqNo: 1,
				C:     prim,
			}},
		}
	}
	for _, c := range table.Columns {
		if isPK(c) && c.Default == nil {
			c.Default = &schema.RawExpr{
				X: fmt.Sprintf("nextval('%s.%s_%s_seq'::REGCLASS)", table.Schema.Name, table.Name, c.Name),
			}
			i, _ := identity(c.Attrs)
			// TODO: prettier
			i.Generation = "generated by default as identity"
			i.Sequence = &Sequence{Start: defaultSeqStart, Increment: defaultSeqIncrement}
			for j := 0; j < len(c.Attrs); j++ {
				switch c.Attrs[j].(type) {
				case *Identity:
					c.Attrs[j] = i
				}
			}
		}
		switch t := c.Type.Type.(type) {
		// cockroach integer types are aliased, see: https://www.cockroachlabs.com/docs/v21.2/int.html#names-and-aliases.
		case *schema.IntegerType:
			switch t.T {
			case TypeBigInt, TypeInteger, TypeInt8, TypeInt64, TypeInt:
				t.T = TypeBigInt
			case TypeInt2, TypeSmallInt:
				t.T = TypeSmallInt
			}
			// json is alias for jsonb
		case *schema.JSONType:
			switch t.T {
			case TypeJSON:
				t.T = TypeJSONB
			}
		}
	}
}

func isPK(c *schema.Column) bool {
	_, ok := identity(c.Attrs)
	return ok
}

func (cd *crdbDiff) Normalize(from, to *schema.Table) {
	// crdb has some specific quirks to normalize
	cd.crdbNormalize(from)
	cd.crdbNormalize(to)
	cd.normalize(from)
	cd.normalize(to)
}
